"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[5970],{2503:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"trouble-integration","title":"Integration","description":"My code just keeps running","source":"@site/versioned_docs/version-v3.4.0/trouble-integration.md","sourceDirName":".","slug":"/trouble-integration","permalink":"/docs/v3.4.0/trouble-integration","draft":false,"unlisted":false,"tags":[],"version":"v3.4.0","lastUpdatedBy":"Gijs Vermari\xebn","lastUpdatedAt":1728914606000,"frontMatter":{"id":"trouble-integration","title":"Integration"},"sidebar":"docs","previous":{"title":"Compilation Issues","permalink":"/docs/v3.4.0/trouble-compile"},"next":{"title":"Core Physics","permalink":"/docs/v3.4.0/physics-core"}}');var i=n(4848),s=n(8453);const r={id:"trouble-integration",title:"Integration"},a=void 0,l={},c=[{value:"My code just keeps running",id:"my-code-just-keeps-running",level:2},{value:"Crashing/Stalling Model Runs",id:"crashingstalling-model-runs",level:2}];function u(e){const t={a:"a",code:"code",h2:"h2",p:"p",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h2,{id:"my-code-just-keeps-running",children:"My code just keeps running"}),"\n",(0,i.jsx)(t.p,{children:"If you're working in jupyter notebooks, fortran output will often not be printed to the cell outputs until the cell finishes running. This can be a real problem if the integration is failing because UCLCHEM may be printing warnings to the screen but you won't see them. If your code is running for a few minutes in a notebook, you may want to export the code to a python script and run it. The uclchem output will print to the console and you will see the integration errors piling up."}),"\n",(0,i.jsx)(t.h2,{id:"crashingstalling-model-runs",children:"Crashing/Stalling Model Runs"}),"\n",(0,i.jsx)(t.p,{children:"Chemical ODEs are infamously stiff and, as such, difficult to solve. There's also no single solver configuration we can use that will guarantee an efficient and accurate solution to every single problem. In particular, if you have a very large network or one with very fast reactions, you may find the integrator stuggles."}),"\n",(0,i.jsx)(t.p,{children:'You\'ll know the integrator is struggling if you find you get a lot of printed messages stating "ISTATE = -n" (where n is some integer). If the model run completes and there is nothing obviously wrong (eg oscillations) then its likely the solution is fine and your network/parameter combination is at the edge of what the solver can handle. If it takes a very long time or never completes, there is an issue.'}),"\n",(0,i.jsxs)(t.p,{children:["One good method to check the validity of your solution is to use the element conservation functions in the ",(0,i.jsx)(t.a,{href:"/docs/pythonapi#uclchem.analysis.check_element_conservation",children:"python module"}),". The integrator typically fails to conserve elemental abundances when the integration has accumulated too large an error. Thus, checking for conservation can reassure you that the integration was successful even if the integrator struggled."]}),"\n",(0,i.jsxs)(t.p,{children:["To fix this, your first port of call should be the ",(0,i.jsx)(t.code,{children:"abstol_factor"}),", ",(0,i.jsx)(t.code,{children:"abstol_min"})," and ",(0,i.jsx)(t.code,{children:"reltol"})," parameters. The comments in ",(0,i.jsx)(t.code,{children:"src/fortran_src/dvode.f90"})," give a fantastic overview of the integrator but in essence, DVODE takes two parameters: ",(0,i.jsx)(t.code,{children:"reltol"})," should set the decimal place accuracy of your abundances and ",(0,i.jsx)(t.code,{children:"abstol"})," the overall error you'll accept. In UCLCHEM, reltol is just a number but we use DVODE's option of making ",(0,i.jsx)(t.code,{children:"abstol"})," a vector with one value per species instead of a single value. This allows us to change the error tolerance depending on the species abundances. ",(0,i.jsx)(t.code,{children:"abstol"})," will take the value of ",(0,i.jsx)(t.code,{children:"abstol_factor"})," times the species abundance or ",(0,i.jsx)(t.code,{children:"abstol_min"}),", whichever is larger."]}),"\n",(0,i.jsxs)(t.p,{children:["Changing the tolerances is a dark art and it isn't necessarily the case that smaller values = more accuracy and larger values = faster integration. Trying a few values (particularly of ",(0,i.jsx)(t.code,{children:"abstol_factor"}),") is always a good first step when you hit integrator problems."]}),"\n",(0,i.jsx)(t.p,{children:"If that doesn't work, you should investigate whether your network is reasonable. Duplicated reactions and bad rate coefficients can result in reactions going too quickly and breaking the integrator."})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var o=n(6540);const i={},s=o.createContext(i);function r(e){const t=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);