"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[4663],{5587:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>s,metadata:()=>a,toc:()=>l});var o=n(2540),i=n(8453);const s={id:"dev-python-wrap",title:"Writing The Python Interface"},r=void 0,a={id:"dev-python-wrap",title:"Writing The Python Interface",description:"The python interface is a relatively complex bit of code, a lot of work is put on the development side to make the user side a smooth experience. Writing the core of UCLCHEM in Fortran gives great performance benefits but compiling it to python with F2PY has its peculiarities. Here, we discuss the steps needed to adjust the code.",source:"@site/versioned_docs/version-v3.4.0/dev-python-wrap.md",sourceDirName:".",slug:"/dev-python-wrap",permalink:"/docs/dev-python-wrap",draft:!1,unlisted:!1,tags:[],version:"v3.4.0",lastUpdatedBy:"Gijs Vermari\xebn",lastUpdatedAt:1728914606e3,frontMatter:{id:"dev-python-wrap",title:"Writing The Python Interface"},sidebar:"docs",previous:{title:"Overview of the Code",permalink:"/docs/dev-overview"},next:{title:"Debugging",permalink:"/docs/dev-debugging"}},c={},l=[{value:"The Fortran Side",id:"the-fortran-side",level:2},{value:"The Python Side",id:"the-python-side",level:2},{value:"Tips and Tricks",id:"tips-and-tricks",level:2}];function d(e){const t={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"The python interface is a relatively complex bit of code, a lot of work is put on the development side to make the user side a smooth experience. Writing the core of UCLCHEM in Fortran gives great performance benefits but compiling it to python with F2PY has its peculiarities. Here, we discuss the steps needed to adjust the code."}),"\n",(0,o.jsx)(t.h2,{id:"the-fortran-side",children:"The Fortran Side"}),"\n",(0,o.jsxs)(t.p,{children:["The fortran side is the more difficult. We define a module in ",(0,o.jsx)(t.code,{children:"src/fortran_src/wrap.f90"})," which is a Fortran module that F2PY will turn into a python module. Any subroutine declared in ",(0,o.jsx)(t.code,{children:"wrap.f90"})," will become a function in the Python module."]}),"\n",(0,o.jsxs)(t.p,{children:["The most likely change you'll want to make is to add a physics module so we'll look at cloud as an example. In ",(0,o.jsx)(t.code,{children:"wrap.f90"})," cloud is declared:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-fortran",children:"    SUBROUTINE cloud(dictionary, outSpeciesIn,abundance_out,successFlag)\n        USE cloud_mod\n\n        CHARACTER(LEN=*) :: dictionary, outSpeciesIn\n        DOUBLE PRECISION :: abundance_out(500)\n        INTEGER :: successFlag\n        !f2py intent(in) dictionary,outSpeciesIn\n        !f2py intent(out) abundance_out,successFlag\n        ...\n    END SUBROUTINE\n"})}),"\n",(0,o.jsxs)(t.p,{children:["where we've dropped the bulk of the code since we only care about the declaration. Once compiled, you will be able to call this function using ",(0,o.jsx)(t.code,{children:"uclchem.wrap.cloud(dictionary,outSpeciesIn)"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["This works because we've done two things. First, we've declared both the two inputs and the two outputs as arguments in Fortran in the normal way. Both inputs and outputs of a subroutine are declared as arguments in Fortran, usually with an ",(0,o.jsx)(t.code,{children:"INTENT(IN)"})," or ",(0,o.jsx)(t.code,{children:"INTENT(OUT)"})," statement, although that is unnecessary. We then declare the intent of those argument for F2PY using the comments that start ",(0,o.jsx)(t.code,{children:"!f2py"})," to tell F2PY which arguments should be arguments of the corresponding python function and which should be outputs."]}),"\n",(0,o.jsx)(t.h2,{id:"the-python-side",children:"The Python Side"}),"\n",(0,o.jsxs)(t.p,{children:["We could leave it at that. However, for ease of use, we write pure python functions in the uclchem module which call the underlying wrap functions rather than having users directly access the f2py functions. For example, in ",(0,o.jsx)(t.code,{children:"uclchem.model"}),", we define a cloud function which calls ",(0,o.jsx)(t.code,{children:"wrap.cloud"}),":"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-python",children:'\ndef cloud(param_dict=None, out_species=None):\n    """Run cloud model from UCLCHEM\n\n    Args:\n        param_dict (dict,optional): A dictionary of parameters where keys are any of the variables in defaultparameters.f90 and values are value for current run.\n        out_species (list, optional): A list of species for which final abundance will be returned. If None, no abundances will be returned.. Defaults to None.\n\n    Returns:\n        int,list: A integer which is negative if the model failed to run, or a list of abundances of all species in `outSpecies`\n    """\n    n_out,param_dict,out_species=_reform_inputs(param_dict,out_species)\n    abunds, success_flag = wrap.cloud(dictionary=param_dict, outspeciesin=out_species)\n    if success_flag < 0 or n_out == 0:\n        return success_flag\n    else:\n        return abunds[: n_out]\n'})}),"\n",(0,o.jsx)(t.p,{children:"This allows us to make some arguments optional using python's keyword arguments. It also lets us write docstrings from which we can generate documentation for the functions. Finally, it lets us tidy up the output! For example, arrays passed too and from the Fortran subroutines must be of fixed length so in this function, we cut the output abundance array down to just the elements the user actually wanted."}),"\n",(0,o.jsx)(t.h2,{id:"tips-and-tricks",children:"Tips and Tricks"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"Once imported, all values are initialized in UCLCHEM. Calling a subroutine multiple times does not reset variables. That is to say that if your Fortran modules declare variables with an initial value, those variables will not return to those initial values. Instead, you'll notice all our modules reset their variables manually in the initialize functions such as initializePhysics."}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"Debugging your fortran code can be greatly complicated by the F2PY interface. Consider compiling the fortran source to test any code changes before trying to compile the python version."}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["Python handles errors much more gracefully than Fortran. We have tried to use ",(0,o.jsx)(t.code,{children:"successFlag"})," as a return from most subroutines as a way to tell Python that the Fortran run failed. It can be a pain to set up the chain of successFlag returns from modules in Fortran but if you use something like Fortran's ",(0,o.jsx)(t.code,{children:"STOP"}),", you'll likely kill your python in a way that won't let you use ",(0,o.jsx)(t.code,{children:"try:, except:"})," statements to handle it."]}),"\n"]}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var o=n(3696);const i={},s=o.createContext(i);function r(e){const t=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);